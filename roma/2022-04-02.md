# 04.02 독서 인증

---
## 객체 지향과 디자인 패턴 (104 - 136)

---

- 오늘은 SOLID에 대해서 읽었다. 휘발될 것 같으니 얼른 적어놔야겠다.

- SOLID는 일종의 설계 원칙이다. 보다 사용자 관점에서 좋은 설계를 하기 위한 지침이라고 볼 수 있다. 책을 읽으면서 과연 내가 얼마나 좋은 설계를 해왔을까를 반성하게 되었다.

- SRP : 단일 책임 원칙
    - `하나의 클래스는 하나의 책임을 져야한다.`
    - 말 그대로 한 클래스에서 단일한 책임을 져야한다는 내용이다. 내 체스 코드가 이렇게 지저분해진 걸 보면 나는 적당한 클래스에 적당한 책임을 분리하지 못했던 것 같기도 하다.
    - 하나의 책임을 질 경우 변경이 한 클래스 내부에서만 발생하고 나머지 코드에는 영향을 미치지 않게 할 수 있다.
    - 이 단일한 책임을 주는 것이 아직은 좀 어려운 것 같다.

- OCP : 개방 폐쇄 원칙
    - `확장에는 열려 있고 변경에는 닫혀있어야 한다.`
    - 말이 어렵다. 이는 프로그램 요구사항이 변경되었을 때 이에 대한 코드 변경은 최소화하면서 새로운 요구사항을 적용시킬 수 있어야 함을 의미한다.
    - 결국엔 추상화를 통해서 이를 지킬 수 있다. 개방 폐쇄 원칙을 어기는 코드의 전형적인 특징은 다음과 같다.
        - 다운 캐스팅을 한다
        - 비슷한 if-else 블록이 존재한다.
    - 상화별로 변경되는 부분이 보인다면 이에 대한 구현을 추상화하여 개방 폐쇄 원칙을 지켜보자

- LSP : 리스코프 치환 원칙
    - `상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.`
    - 말이 어렵다. 상위 타입 객체를 파라미터로 정의된 메서드가 있다면 이에 하위 타입의 객체를 집어넣을 경우에 동일하게 동작해야 함을 의미한다.
    - 이는 명세에 관한 내용이다. 상위 타입의 객체를 상속받는 객체라면 마땅히 상위 타입의 객체에서 이루어질 것이라고 생각하고 정의된 명세를 따를 수 있어야 한다.
    - instance of를 쓰지 않아야할 이유가 또 여기있다. 하위 구체 클래스에서 상위 클래스를 대체하지 못하기 때문에 이처럼 구체 클래스를 확인해야하기 때문이다.

- ISP : 인터페이스 분리 원칙
    - `인터페이스는 그 인터페이스를 사용하는 클라이언트 기준으로 분리해야 한다.`
    - 가장 이해가 잘 안가는 원칙이었다. C++로 설명해서 그런가?
    - 자신이 사용하는 메서드에만 의존하라는 뜻인데, 즉 클라이언트 입장에서 사용하는 기능만 제공하도록 인터페이스를 분리하라는 뜻이라고 한다.
    - 의존의 양면성 : A가 B를 의존할 경우 B의 변화로 인해 A가 변경된다. 반대로 A의 요구에 의해 B가 변경될 수 있다.
        - 인터페이스를 분리하는 기준이 클라이언트로 하라는 뜻. 클라이언트가 사용하는 기능을 중심으로 인터페이스를 분리함으로써 클라이언트로부터 발생하는 인터페이스 변경의 여파가 다른 클라이언트에 미치는 영향을 최소화 할 수 있다.    
    - 아직도 잘 이해는 안된다. ㅋ

- DIP : 의존 역전 원칙
    - `고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.`
    - 즉, 고수준 모듈에서 저수준 모듈을 직접 사용하지 않고 그 사이에 추상 타입을 두어 `고수준 모듈 -> 저수준 모듈` 로 가는 의존관계를 끊어 `고수준 모듈 -> 추상 타입`, `저수준 모듈 -> 추상 타입` 요런 느낌으로 만들라는 뜻이다.
        - 해당 추상 타입은 고수준 모듈이 존재하는 패키지로 두는 것이 좋다 (상세 구현의 독립적 배포를 위함)

- SOLID 아직 어렵지만 이를 다시 상기시켜서 내 코드에서도 이 원칙들을 잘 지키고 있는지 봐야겠다. 리팩토링할 때 SOLID를 계속 되뇌이자!
