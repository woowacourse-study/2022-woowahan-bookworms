# 03.14 독서 인증

## 모던 자바스크립트 Deep Dive (p.422 ~ 450)

### 24장. 클로저

#### 클로저란?

- 함수가 선언된 렉시컬 환경을 통해, 이미 실행이 종료된 함수에서 선언된 변수에도 접근할 수 있는 현상.
- 어떤 함수 내부에 중첩 함수가 정의되었을 때, 중첩 함수는 자신이 포함된 함수의 변수에 접근할 수 있는 현상.
- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 외부 함수의 생존 여부(실행 컨텍스트의 생존 여부)와 상관없이, 상위 스코프를 참조할 수 있고, 상위 스코프의 식별자를 참조하고 그 값을 변경할 수도 있는 현상. (실행 컨텍스트의 소멸과 실행 컨텍스트의 렉시컬 환경이 소멸하는 시점이 다르다는 점에 주의하자.)

- 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고, 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.

  1. 중첩 함수가 외부 함수보다 더 오래 유지되지만, 상위 스코프의 어떤 식별자도 참조하지 않는다면 이는 클로저라고 할 수 없다.
     상위 스코프의 어떤 식별자도 참조하지 않는 경우, 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다.
  2. 중첩 함수가 외부 함수의 식별자를 참조하지만, 외부 함수 밖으로 중첩 함수가 반환되지 않아 중첩 함수의 생명주기가 더 짧다면, 생명 주기가 종료된 외부 함수의 식별자를 참조할 수 있는 현상이 나타나지 않으므로, 클로저라고 할 수 없다.

- 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수(free variable)이라고 부른다. 클로저라는 표현은 자유 변수에 함수가 묶여 있는(closed) 것을 의미한다.

#### 렉시컬 스코프

- 클로저가 나타나는 이유는, 자바스크립트가 함수 호출이 아닌 함수 정의 위치에 따라 상위 스코프를 결정하는 렉시컬 스코프(정적 스코프) 방식을 따르기 때문이다.
  함수가 정의된 위치와 호출되는 위치는 다를 수 있다. 렉시컬 스코프가 가능하려면, 함수는 자신의 정의된 환경인 상위 스코프를 기억해야 한다.
  함수 정의가 평가될때, 함수는 상위 스코프를 [[Environment]] 내부 슬롯에 저장한다. 따라서 함수는 자신이 존재하는 한 상위 스코프를 기억할 수 있게 된다.

- let이나 const 키워드를 사용하는 반복문은, 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여, 반복 당시의 상태를 스냅샷을 찍듯 저장한다. 반복문의 코드 블록 내부에서 함수를 정의하면, 정의된 함수의 상의 스코프는 이 스냅샷처럼 저장된 렉시컬 환경이 된다.

#### 클로저의 활용

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태가 의도치 않게 변경되지 않도록 은닉하고, 특정 함수에게만 상태 변경을 허용한다.

<br />

# 03.15 독서 인증

## You Don't Know JS (p.26 ~ 65)

### Part 1. 타입과 문법

#### 1장. 타입

- 자바스크립트에는 7가지 내장 타입이 있다. 7가지 중 object를 제외한 이들을 원시 타입(primitive)이라고 한다.

  null, undefined, boolean, number, string, object, symbol(ES6 추가)

- 값은 타입을 가진다. 값의 타입은 `typeof` 연산자로 알 수 있다.

  - 주의할 것은, null에 대한 연산 결과가 'object'라는 점이다. null 값을 정확히 확인하려면 두 가지를 확인해야한다. 1. 타입은 'object'이고 2. falsy한 값인가.

  - 'undefined'는 접근 가능한 스코프에 변수가 선언되었으나 값이 할당되지 않은 상태임을 의미한다. 값만 없다는 뜻이다.

    반면 변수 자체가 선언조차 되지 않은 것은 'undeclared'다. 이 경우 'ReferenceError: ??? is not defined'가 나타난다.

    그런데 undefined 변수든, undeclared 변수든 `typeof` 연산 결과는 모두 'undefined'다. 만약 ReferenceError를 피하고 싶다면, 브라우저가 오류 처리를 하지 않기를 원한다면 `typeof`를 이용하여 안전하게 존재 여부를 확인할 수 있다.

- 변수는 언제라도 어떤 형태의 값을 가질 뿐이다. 값에는 타입이 있고, 값을 가지는 변수에는 타입이 없다. 변수에 `typeof` 연산자를 대어보는 것은 정확히는 '이 변수에 들어있는 값의 타입이 무엇이냐'고 묻는 것이다.

<br />

#### 2장. 값

- null 타입은 값이 null 하나뿐이고, undefined 타입도 값이 undefined 하나뿐이다. undefined는 할당된 값이 없는 모든 변수, 프로퍼티의 default value다.
- `void` 연산자는 어떤 값이라도 undefined로 만든다. `void`연산은 어떤 식의 결괏값이 없다는 걸 확실히 밝힐 때 요긴하게 쓸 수는 있다. 값이 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에 void를 사용할 수 있다. 다만, return에 필요한 경우에는 return 문을 분리하여 결괏값 없이 return 하는 방식을 선호하는 개발자들이 많다.
- NaN의 type은 Number다. NaN은 '숫자가 아니다'라기보다 '유효하지 않은 숫자'라고 표현하는 것이 더 정확하다. NaN은 NaN 자기 자신과 직접 비교할 수 없다. NaN !== NaN이다. NaN을 확인하기 위해서는, `Number.isNaN()`을 이용한다. 이 외에도 숫자에는 +Infinity, -Infinity, -0 같은 특수 값이 있다.
- ES6부터는 두 값이 절대적으로 동등한지 확인하는 유틸리티 `Object.is()`를 지원한다.
- 자바스크립트의 레퍼런스는 다른 언어의 레퍼런스, 포인터와는 다른 개념으로, 다른 변수나 레퍼런스가 아닌 '값'을 가리킨다.

<br />

# 03.16 독서 인증

## You Don't Know JS (p.193 ~ 204)

### Part 2. 스코프와 클로저

#### 1장. 스코프란 무엇인가

변수를 프로그램에 추가하면, 다음과 같은 질문이 생긴다.

- 변수는 어디에 살아있는가? 변수는 어디에 저장되는가?
- 필요할 때 프로그램은 어떻게 변수를 찾는가?

특정 장소에 변수를 저장하고, 나중에 변수를 찾는 데에 잘 정의된 규칙이 필요하다. 이런 규칙을 스코프(Scope)라고 한다.

#### 1.1 컴파일러 이론

자바스크립트는 컴파일러 언어다. 전통적인 컴파일러 언어처럼 미리 코드를 컴파일하거나, 결과를 분산 시스템에서 이용할 수 있는 것은 아니다. 전통적인 컴파일러 언어의 처리 과정에서는 소스 코드 실행 전에, 컴파일레이션(Compilation)이라는 3단계를 거친다.

1. 토크나이징(Tokenizing) / 렉싱(Lexing) - 소스 코드 문자열을 나누어 토큰(token) 단위의 의미있는 조각으로 만드는 과정.
2. 파싱(Parsing) - 토큰 배열을 프로그램 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정. 파싱 결과로 만들어진 트리를 추상 구문 트리 AST(Abstract Syntax Tree)라 부른다.
3. 코드 생성(Code-Generation) - AST를 실행 코드로 바꾸는 과정
   자바스크립트 엔진이 기존 컴파일러와 다른 점은, 컴파일레이션을 미리 수행하지 않아서 최적화할 시작이 많지 않다는 것이다. 자바스크립트 컴파일레이션은 보통 코드가 실행되기 겨우 수백만 분의 일초 전에 수행한다.

#### 1.2 스코프 이해하기

'var a = 2;'라는 구문이 주어지면, 컴파일러는 가장 먼저 토크나이징을 통해 구문을 토큰으로 쪼갠다. 그리고 파싱해 트리 구조로 만든다.
그리고 코드 생성 과정에 들어가면, 컴파일러는 다음 일을 진행한다.

1. 'var a'를 만나면, 스코프에 변수 a가 특정 스코프 내에 있는지 묻는다. 있다면 이 선언을 무시하고 지나간다. 없다면 새로운 변수 a를 스코프 내에 선언하라고 요청한다.
2. 컴파일러는 'a = 2' 대입문을 처리하기 위해, 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 코드를 실행하면, 코드는 먼저 a라는 변수에 현재 스코프 내에서 접근할 수 있는지 확인한다. 가능하다면 확인된 변수 a를 사용하고, 아니라면 다른 중첩 스코프를 살핀다. 엔진이 변수를 마침내 찾으면 변수에 값 2를 넣고, 못 찾으면 에러가 발생했다고 소리칠 것이다.

#### 1.3 중첩 스코프

스코프는 확인자 이름으로 변수를 찾기 위한 규칙의 집합이다. 하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로, 스코프도 다른 스코프 안에 중첩될 수 있다. 중첩 스코프를 확인할 때 사용하는 규칙은 간단하다.

1. 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾기 못하면 한 단계씩 올라간다.
2. 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

#### 1.4 오류

대입할 대상을 검색할 때는 LHS 검색, 대입한 값을 검색할 때는 RHS 검색을 한다. 예를 들어, 어떤 대입 연산문이 있을 때, LHS 검색은 대입 연산자의 왼쪽에 있을 때 수행하고, RHS 검색은 변수가 대입 연산자의 오른쪽에 있을 때 수행한다. 이 두 검색 방식은, 변수를 스코프에서 검색하는 과정에서 찾지 못 했을 때 서로 다르게 동작한다. RHS 검색이 중첩 스코프 안 어디서도 변수를 찾지 못하면 엔진은 'ReferenceError'를 발생시킨다. 반면 LHS 검색이 변수를 찾지 못해 최상위 층에 도착할 때는, 프로그램이 'Strict Mode'로 동작하고 있는 것이 아니라면, 글로벌 스코프가 엔진이 검색하는 이름의 변수를 새로 생성해서 넘겨준다. 없지만 하나 만들어주는 것이다. RHS 검색 결과 변수를 찾았지만 그 값으로 불가능한 일을 하려고 한다면, 엔진은 TypeError를 발생시킨다.

<br />

# 03.17 독서 인증

## Clean Code (p.144 ~ 157)

### 8장. 경계

- 경계 인터페이스를 이용할 때는 사용해서는 안 되는 기능이 밖으로 노출되지 않도록 주의하라. 경계 인터페이스를 클래스 안으로 숨기면, 코드를 이해하기는 쉽지만 오용하기는 어려워진다. 프로그램에 필요한 인터페이스만 제공하여, 다른 프로그램이 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.
- 외부 코드에 대한 간단한 테스트 케이스를 작성해, 이를 충족하는 과정에서 외부 코드에 대해 많은 이해와 필요한 지식을 얻을 수 있다. 이를 학습 테스트라고 부른다.
- 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트가 버전 업데이트에 따른 새로운 위험을 방할 수 있고, 또 패키지의 새 버전으로 이전하기 쉬워진다.
- 아는 코드와 아직 모르는 코드에 대한 경계를 구분할 수 있다. 아직 모르는 코드를 사용하는 구체적인 방법은 모르지만, 기대하는 동작에 대해 자체적으로 인터페이스는 정의할 수 있다. 바라는 인터페이스를 구현하여 인터페이스를 전적으로 통제할 수 있게 된다. 코드 가독성도 높아지고 코드 의도도 분명해지며, 테스트에도 용이하다.
- 경계에서는 변경이 많이 일어난다. 설계가 우수하다면 변경에 많은 투자가 필요하지 않다. 따라서 경계에 위치하는 코드는 깔끔하게 분리한다. 경계 인터페이스를 사용하여 외부 패키지를 호출하는 코드를 가능한 줄이며 경계를 관리한다. 그러면 코드 가독성이 높아지고, 경계 인터페이스를 사용하는 일관성이 높아지며, 외부 패키지의 변경이 있을 때, 적은 변경으로 대응할 수 있다.

### 9장. 단위 테스트

- 코드의 유연성, 유지보수성, 재사용성을 제공하는 버팀목은 바로 단위 테스트다. 테스트 커버리지가 높으면 변경에 대한 공포와 두려움이 줄어든다. 안심하고 아키텍처와 설계를 개선할 수 있다.
- 지저분한 테스트 코드는 테스트를 안 하느니만 못 하다. 지저분한 테스트 코드는 결국 부담이 되어 폐기하는 상황에 처한다. 테스트 코드가 없으면 개발자는 자신이 수정한 코드가 제대로 동작하는지 확인할 방법이 없다. 확인을 하지 못하니 수정에 따른 결함이 많아지고, 그러다보면 결국 개발자는 수정이 득보다 해가 크다 생각해 더 이상 수정하지 않게 된다. 결국 코드가 망가진다. 따라서 테스트 코드는 실제 코드 못지 않게 깨끗하게 짜야 한다.

<br />

# 03.18 독서 인증

## You Don't Know JS (p.205 ~ 219)

### Part 2. 스코프와 클로저

#### 2장 렉시컬 스코프

- 컴파일레이션 과정의 첫 번째 단계는 토크나이징(Tokenizing) 또는 렉싱(Lexing)이라 불리는 작업이다. 이 작업은 소스 코드 문자열을 분석하여 상태 유지 파싱의 결과로 생성된 토큰에 의미를 부여한다. 바로 렉시컬 스코프는 이 렉싱 타임(Lexing Time)에 정의되는 스코프다. 렉시컬 스코프는 개발자가 코드를 짤 때, 변수와 스코프 블록을 어디서 작성하는가에 기초하여 Lexer가 코드를 처리할 때 확정된다. 어떤 함수가 어디서 어떻게 호출되는지에 상관없이 함수의 렉시컬 스코프는 함수가 선언된 위치에 다라 정의된다.

- 어떤 함수도 두 개의 부모 함수 안에 속할 수 없는 것처럼, 스코프 또한 하나의 상위 스코프만을 가질 수 있다. 엔진은 스코프 중첩의 구조와 상대적 위치를 통해 identifier를 찾는다. 스코프는 목표와 일치하는 대상을 찾는 즉시 검색을 중단한다. 때문에 여러 중첩 스코프에 걸쳐 같은 identifier 이름을 정의할 수 있다. 항상 실행 시점에서 가장 안쪽 스코프에서 시작하여, 최초로 목표와 일치하는 대상을 찾으면 멈추고, 그 전까지는 밖으로 혹은 위로 올라가면서 검색을 수행한다.
- 렉시컬 스코프 검색 과정은 first-class identifier에만 적용된다. 만약 foo.bar.bax를 찾는다면, 렉시컬 스코프 검색은 foo 확인자를 찾는 데 사용되고, foo을 찾은 후에는 객체 속성 접근 규칙을 통해 bar, baz 속성을 가져온다.
- 렉시컬 스코프 속이기
  - `eval()` 은 문자열을 인자로 받는다. 이 분자열일 하나 이상의 변수, 함수 선언문을 포함하면 `eval()`은 그 코드를 실행하면서 호출된 위치의 렉시컬 스코프를 수정한다. 개발자가 작성했던 때의 렉시컬 스코프를 런타임에 수정할 수 있다.
  - `with`는 일반적으로 한 객체의 여러 속성을 참조할 때, 객체 참조를 매번 반복하지 않기 위해 사용하는 기법이다. with문은 속성을 가진 객체를 받아, 마치 하나의 독립된 렉시컬 스코프처럼 취급한다. 객체의 속성은 모두 해당 스코프에 정의된 identifier로 간주된다. 그리고 with 블록 내에서 일반적인 var 선언문이 수행된다면, 선언된 변수는 with 블록이 아닌 with 문을 포함하는 함수의 스코프에 속한다. 이때 발생하는 특이한 부작용이 있다. 만약 정의되지 않은 속성에 대한 대입문이 있다면? LHS 검색 규칙에 따라, identifier를 검색하며 글로벌 스코프에 도달하고, 글로벌 스코프에서도 찾을 수 없으니, 자동으로 그에 해당하는 글로벌 변수가 생성된다.
  - 자바스크립트 엔진은 컴파일레이션 단계에서 상당수의 최적화 작업을 진행한다. 최적화의 일부 핵심 작업은 렉싱된 코드를 분석하여 변수와 함수 선언문이 어디있는지 파악하고 실행 과정에서 identifier 검색을 더 빠르게 하는 것이다. 그런데 `eval()`이나 `with`가 코드에 있다면 어떻게 렉시컬 스코프가 수정되고 생성될지 알 수 없고, 엔진은 identifier의 위치가 틀릴 수도 있다고 가정해야 한다. 따라서 `eval()`이나 `with`를 사용하면 대다수 최적화가 의미 없어져서 최적화를 하지 않은 것이나 마찬가지가 된다. 따라서 코드가 더 느리게 동작하게 되므로 이는 사용하지 말자!

#### 3장 함수 vs 블록 스코프

- 함수 스코프는 모든 변수가 함수에 속하고, 함수 전체에 걸쳐 사용되며 재사용된다는 개념을 확고하게 한다. 이는 상당히 유용하지만 스코프 전체에서 변수가 살아있다는 점이 예상치 못한 문제를 만들기도 한다.

#### 스코프에 숨기

- 함수 내의 모든 변수 또는 함수 선언문은, 코드를 감싼 함수의 스코프에 묶인다. 함수의 스코프로 둘러싸서 변수와 함수를 숨길 수 있다는 말이다.
- 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고, 나머지는 숨기기 위해 스코프를 사용할 수 있다. 모든 변수와 함수가 글로벌 스코프에 존재한다면 중첩된 모든 하위 스코프에서 이들에게 접근할 수 있다. 접근할 필요가 없어서 비공개로 남겨야할 많은 변수가 함수를 노출시키게 된다. 접근 가능한 identifier는 의도적이든 생각지 못한 방식으로든 사용될 수 있다. 이를 막기 위해서는 비공개 부분을 함수의 스코프 내부에 숨길 수 있다.
- 스코프에 안에 변수와 함수를 숨겨, 같은 이름을 가졌지만 다른 용도를 가진 두 identifier가 충돌하는 것을 피할 수 있다. 소프트웨어 설계를 하다 보면 자연스럽게 같은 확인자 이름을 사용하게 되므로, 스코프를 이용해서 내부에 선언문을 숨기는 것은 좋은 선택지다.

<br />
