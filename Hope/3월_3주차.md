# 03.14 독서 인증

# You don't know JS 177-204
- 프로그램에서 `지금`에 해당하는 부분 그리고 `나중`에 해당하는 부분 사이의 관계가 바로 비동기성의 핵심

## 프로그램 덩이
- 가장 일반적인 프로그램 덩이는 함수
- 나중은 지금의 직후가 아니다. `지금 당장 끝낼 수 없는 작업은 비동기적으로 처리되므로,프로그램을 중단(Blocking)하지 않는다.`
- 동기적인 ajax 요청을 하게 된다면 무슨일이 벌어질까?
   - 브라우저 UI를 얼어붙게 할 뿐 아니라, 사용자와의 상호작용이 완전히 마비될 수 있다.

```javascript
function now(){
    return 21;
}

function later() {
    answer = answer * 2;
   console.log("인생의 의미", answer);
}

var answer = now();

setTimeout(later, 1000);
```

```javascript
// 지금 덩이 
function now(){
    return 21;
}

function later() {...}

var answer = now();

setTimeout(later, 1000);
```


```javascript
// 나중 덩이
    answer = answer * 2;
   console.log("인생의 의미", answer);
```


### 비동기 콘솔
- Console.* 메서드는 그 작동방법이나 요건이 명세에 따로 정해져있지 않지만 호스팅 환경에 추가된 기능이다.
- 따라서 브라우저와 자바스크립트 실행환경에 따라 작동방식이 다르다.
- 특히 console.log()메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수도 있다.
- I/O부분이 가장 느리고 중단이 잦기 때문이다. 따라서, 브라우저가 콘솔 I/O를 백그라운드에서 비동기적으로 처리해야 성능상 유리하다.


## 이벤트 루프
- 자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한 덩이씩 묵묵히 실행할 뿐이다.
- 그러면 누가 요청하는가?
- 자바스크립트 엔진은 혼자서는 안되고 반드시 호스팅에서 실행된다. (웹브라우저, 노드js)
- 그러나 환경은 달라도 쓰레드는 공통이다. 
    - 여러 프로그램 덩이를 시간에 따라 매 순간 한 번씩 엔진을 실행시키는 이벤트 루프라는 장치
- 자바스크립트 엔진은 애초 시간이란 관념이 없고, 임의의 자바스크립트 코드를 시시각각 주는대로 받아 처리하는 실행기일뿐, 이벤트(코드)를 스케쥴링하는 일은 언제나 엔진을 감싸고 있던 주위 환경의 몫인 것이다. 

```javascript
var eventLoop = [ ];
var event;

while(true){
    if(eventLoop.length > 0){ // Tick!
         event = eventLoop.shift();
         try{
          event(); 
       }catch(error){
           reportError(err); 
       }
    }
}
```

- Tick : 루프의 매 순회 
- 틱이 발생 할 때 마다 큐에 적재된 이벤트(콜백 함수)를 꺼내어 실행한다.
- setTimeout은 콜백을 이벤트 루프 큐에 넣지 않는다. 
- setTimeout은 타이머를 설정하는 함수다. 타이머가 끝나면 환경이 콜백을 이벤트 루프에 삽입한 뒤 틱에서 콜백을 꺼내어 실행한다.
- 이벤트 루프가 원소로 가득 차 있을 때에는? 콜백은 기다린다. -> setTimeout 타이머가 항상 와녑ㄱ하게 정확한 타이밍으로 작동하지 않는 이유이다.
- 즉, setTimeout 함수는 적어도 지정한 시간(Interval)이전에 콜백이 실행되지 않음을 보장할 뿐이다. 


## 병렬 스레딩
- 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근 하거나 변경할 수는 없다.

```javascript
function later(){
   answer = answer*2;
   console.log('인생의 의미
}
```
- 위의 later() 함수 전체 내용은 이벤트 루프 큐가 하나의 원소로 취급하므로 이 함수를 실행 중인 스레드 입장에선 실제로 여러 상이한 저수준의 작업들이 일어날 수 있다.
- 예컨데 '현재 answer 값 조회-> 곱셈 연산 수행 -> 결괏값을 다시 answer 변수에 저장' 순으로 처리한다.
- 단일-스레드 환경에서는 스레드 간섭은 일어나지 않으므로 스레드 큐에 저수준 작업의 원소가 쌓여 있어도 별 문제 없다.
- 하지만 하나의 프로그램에서 여러개의 스레드를 처리하는 병렬 시스템에선 예상치 못했던 일들이 발생 할 수 있다.
- 정확히 똑같은 시점에 두 스레드에서 같은 메모리 공간에 접근하면 어떻게 될까? 정말정말 많은 경우의 수가 발생한다.
- 따라서 자바스크립트는 절대로 스레드 간의 데이터를 공유하지 않아서, 비결정성의 수준은 문제가 되지 않는다.
- 그렇다고 완전히 결정적인가? no

### 완전-실행
- 자바스크립트의 작동 모드는 단일-스레드이므로 내부의 코드는 원자적이다. (한 덩이)
- 일단 foo() 가 실행 되면 이 함수 전체 코드가 실행 된 후, bar()함수가 실행된다는 뜻이다.
- 이를 완전-실행 이라고 한다.
- foo()와 bar()는 상대의 실행을 방해 할 수 없으므로, 프로그램의 결괏값은 먼저 실행되는 함수가 좌우할 수 있다.
- 즉, 자바스크립트의 비결정성은 함수(이벤트)의 순서에 따른 것이지 스레드처럼 문의 순서(표현식 처리의 순서) 수준까지는 아니다. 
- 자바스크립트에서는 함수 순서에 따른 비결정성을 흔히 **경합 조건**이라고 한다.


## 동시성
- 복수의 이벤트들이 연쇄적으로 시간에 따라 인터리빙되면서 고수준의 관점에서 볼 때 (실제로는 특정 시점에 1개의 이벤트만 처리되고 있지만) 꼭 동시에 실행되는 것 처럼 보인다.
- 예를들어 사용자가 스크롤바를 아래로 내리면 게속 갱신된 상태 리스트가 화면에 표시되는 웹페이지
- 위의 예시는 적어도 2개의 분리된 프로세스를 동시에 실행할 수 있어야 한다. 
- 첫번째 프로세스 -> 사용자가 페이지를 스크롤바로 내리는 순간 발생하는 onScroll 이벤트에 반응
- 두번째 프로세스 -> ajax 응답을 받는다.
- 사용자가 아주 빨리 스크롤바를 내리면 처음 수신된 응답을 처리하는 도중 2개 이상의 onScroll 이벤트가 발생할 수 있고, onScroll 이벤트와 Ajax 요청 이벤트가 아주 빠르게 발생하며 인터리빙 된다.
- 동시성은 복수의 프로세스가 같은 시간 동안 동시에 실행됨을 의미하며, 각 프로세스 작업들이 병렬로 처리되는지와는 관계 없다.
- 동시성은 처리수준의 병행성과 상반되는 개념의 프로세스 수준의 병행성이다.

```javascript
onscroll, request1 // 프로세스 1 시작
onscroll, request2
response1 // 프로세스 2 시작
onscroll, request3
response2
response3
onscroll, request4 
onscroll, request5 
onscroll, request6  // 프로세스 1 종료
response4 
onscroll, request7
response6
response5 
response7 // 프로세스 2 종료  
```
- 프로세스 1과 프로세스2는 동시에 실행되지만 이들을 구성하는 이벤트들은 이벤트 루프 큐에서 차례대로 실행된다.


### 비상호작용
- 어떤 프로그램 내에서 복수의 프로세스가 단계/이벤트를 동시에 인터리빙 할 때 이 들 프로세스 사이에 연관된 작업이 없다면 프로세스 간 상호작용은 사실 의미가 없다.
- 프로세스가 상호 작용이 일어나지 않는다면 비결정성은 완벽히 수용 가능하다.

### 상호작용
- 동시 프로세스들은 필요할 때 스코프나 DOM을 통해 간접적으로 상호 작용을 한다.
- 이 때 이미 한번 살펴봤던 것 처럼 경합조건이 발생하지 않도록 잘 조율해줘야한다.
   - 경합조건 : 함수 실행 순서에 따라 결과가 달라지는 것
- 상호작용의 순서를 잘 조율해줘야한다.


### 협동
- 협동적 동시성은 실행 시간이 오래 걸리는 프로세스를 여러 단계/배치로 쪼개어 다른 동시 프로세스가 각자 작업을 이벤트 루프 큐에 인터리빙 하도록 한다.

```javascript
var res = [];

function response (data){
  res = res.concat(
  	data.map(function(val){
      return val*2;
    })
  )
}

ajax("~~", response);
ajax("~~", response)
```
- 위와 같은 함수를 아래처럼 수정한다.
```javascript
var res = [];

function response (data){
  // 1번에 1000개씩만 실행
  var chunk = data.splice(0,1000);
  res =res.concat(
  	chunk.map(function(val){ return val*2 })
  );

  // 아직도 처리 할 데이터가 남아있다면?
  if(data.length > 0){
    // 다음 배치를 비동기 스케쥴링 한다.
    setTimeout(function(){
      response(data);
    },0)
  }
}

ajax("~~", response);
ajax("~~", response)
```


## 문 순서
- 자바스크립트 엔진은 반드시 프로그램에 표현된 문 순서대로 실행하지 않는다.
- 자바스크립트 엔진은 코드를 컴파일 한 뒤, 문 순서를 (안전하게) 재정렬하면서 실행 시간을 줄일 여지는 없는지 확인한다.
- 따라서 소스코드 순서(위->아래)와 컴파일 후 실행 순서는 사실상 아무 관련이 없다.
