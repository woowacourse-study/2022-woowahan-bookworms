# 03.14 독서 인증

## 모던 자바스크립트 Deep Dive (p.422 ~ 450)

### 24장. 클로저

#### 클로저란?

- 함수가 선언된 렉시컬 환경을 통해, 이미 실행이 종료된 함수에서 선언된 변수에도 접근할 수 있는 현상.
- 어떤 함수 내부에 중첩 함수가 정의되었을 때, 중첩 함수는 자신이 포함된 함수의 변수에 접근할 수 있는 현상.
- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 외부 함수의 생존 여부(실행 컨텍스트의 생존 여부)와 상관없이, 상위 스코프를 참조할 수 있고, 상위 스코프의 식별자를 참조하고 그 값을 변경할 수도 있는 현상. (실행 컨텍스트의 소멸과 실행 컨텍스트의 렉시컬 환경이 소멸하는 시점이 다르다는 점에 주의하자.)

- 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고, 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.

  1. 중첩 함수가 외부 함수보다 더 오래 유지되지만, 상위 스코프의 어떤 식별자도 참조하지 않는다면 이는 클로저라고 할 수 없다.
     상위 스코프의 어떤 식별자도 참조하지 않는 경우, 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다.
  2. 중첩 함수가 외부 함수의 식별자를 참조하지만, 외부 함수 밖으로 중첩 함수가 반환되지 않아 중첩 함수의 생명주기가 더 짧다면, 생명 주기가 종료된 외부 함수의 식별자를 참조할 수 있는 현상이 나타나지 않으므로, 클로저라고 할 수 없다.

- 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수(free variable)이라고 부른다. 클로저라는 표현은 자유 변수에 함수가 묶여 있는(closed) 것을 의미한다.

#### 렉시컬 스코프

- 클로저가 나타나는 이유는, 자바스크립트가 함수 호출이 아닌 함수 정의 위치에 따라 상위 스코프를 결정하는 렉시컬 스코프(정적 스코프) 방식을 따르기 때문이다.
  함수가 정의된 위치와 호출되는 위치는 다를 수 있다. 렉시컬 스코프가 가능하려면, 함수는 자신의 정의된 환경인 상위 스코프를 기억해야 한다.
  함수 정의가 평가될때, 함수는 상위 스코프를 [[Environment]] 내부 슬롯에 저장한다. 따라서 함수는 자신이 존재하는 한 상위 스코프를 기억할 수 있게 된다.

- let이나 const 키워드를 사용하는 반복문은, 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여, 반복 당시의 상태를 스냅샷을 찍듯 저장한다. 반복문의 코드 블록 내부에서 함수를 정의하면, 정의된 함수의 상의 스코프는 이 스냅샷처럼 저장된 렉시컬 환경이 된다.

#### 클로저의 활용

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태가 의도치 않게 변경되지 않도록 은닉하고, 특정 함수에게만 상태 변경을 허용한다.

<br />

# 03.15 독서 인증

## You Don't Know JS (p.26 ~ 65)

### Part 1. 타입과 문법

#### 1장. 타입

- 자바스크립트에는 7가지 내장 타입이 있다. 7가지 중 object를 제외한 이들을 원시 타입(primitive)이라고 한다.

  null, undefined, boolean, number, string, object, symbol(ES6 추가)

- 값은 타입을 가진다. 값의 타입은 `typeof` 연산자로 알 수 있다.

  - 주의할 것은, null에 대한 연산 결과가 'object'라는 점이다. null 값을 정확히 확인하려면 두 가지를 확인해야한다. 1. 타입은 'object'이고 2. falsy한 값인가.

  - 'undefined'는 접근 가능한 스코프에 변수가 선언되었으나 값이 할당되지 않은 상태임을 의미한다. 값만 없다는 뜻이다.

    반면 변수 자체가 선언조차 되지 않은 것은 'undeclared'다. 이 경우 'ReferenceError: ??? is not defined'가 나타난다.

    그런데 undefined 변수든, undeclared 변수든 `typeof` 연산 결과는 모두 'undefined'다. 만약 ReferenceError를 피하고 싶다면, 브라우저가 오류 처리를 하지 않기를 원한다면 `typeof`를 이용하여 안전하게 존재 여부를 확인할 수 있다.

- 변수는 언제라도 어떤 형태의 값을 가질 뿐이다. 값에는 타입이 있고, 값을 가지는 변수에는 타입이 없다. 변수에 `typeof` 연산자를 대어보는 것은 정확히는 '이 변수에 들어있는 값의 타입이 무엇이냐'고 묻는 것이다.

<br />

#### 2장. 값

- null 타입은 값이 null 하나뿐이고, undefined 타입도 값이 undefined 하나뿐이다. undefined는 할당된 값이 없는 모든 변수, 프로퍼티의 default value다.
- `void` 연산자는 어떤 값이라도 undefined로 만든다. `void`연산은 어떤 식의 결괏값이 없다는 걸 확실히 밝힐 때 요긴하게 쓸 수는 있다. 값이 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에 void를 사용할 수 있다. 다만, return에 필요한 경우에는 return 문을 분리하여 결괏값 없이 return 하는 방식을 선호하는 개발자들이 많다.
- NaN의 type은 Number다. NaN은 '숫자가 아니다'라기보다 '유효하지 않은 숫자'라고 표현하는 것이 더 정확하다. NaN은 NaN 자기 자신과 직접 비교할 수 없다. NaN !== NaN이다. NaN을 확인하기 위해서는, `Number.isNaN()`을 이용한다. 이 외에도 숫자에는 +Infinity, -Infinity, -0 같은 특수 값이 있다.
- ES6부터는 두 값이 절대적으로 동등한지 확인하는 유틸리티 `Object.is()`를 지원한다.
- 자바스크립트의 레퍼런스는 다른 언어의 레퍼런스, 포인터와는 다른 개념으로, 다른 변수나 레퍼런스가 아닌 '값'을 가리킨다.

<br />

# 03.16 독서 인증

## You Don't Know JS (p.193 ~ 204)

### Part 2. 스코프와 클로저

#### 1장. 스코프란 무엇인가

변수를 프로프램에 추가하면, 다음과 같은 질문이 생긴다.

- 변수는 어디에 살아있는가? 변수는 어디에 저장되는가?
- 필요할 때 프로그램은 어떻게 변수를 찾는가?

특정 장소에 변수를 저장하고, 나중에 변수를 찾는 데에 잘 정의된 규칙이 필요하다. 이런 규칙을 스코프(Scope)라고 한다.

#### 1.1 컴파일러 이론

자바스크립트는 컴파일러 언어다. 전통적인 컴파일러 언어처럼 미리 코드를 컴파일하거나, 결과를 분산 시스템에서 이용할 수 있는 것은 아니다. 전통적인 컴파일러 언어의 처리 과정에서는 소스 코드 실행 전에, 컴파일레이션(Compilation)이라는 3단계를 거친다.

1. 토크나이징(Tokenizing) / 렉싱(Lexing) - 소스 코드 문자열을 나누어 토큰(token) 단위의 의미있는 조각으로 만드는 과정.
2. 파싱(Parsing) - 토큰 배열을 프로그램 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정. 파싱 결과로 만들어진 트리를 추상 구문 트리 AST(Abstract Syntax Tree)라 부른다.
3. 코드 생성(Code-Generation) - AST를 실행 코드로 바꾸는 과정
   자바스크립트 엔진이 기존 컴파일러와 다른 점은, 컴파일레이션을 미리 수행하지 않아서 최적화할 시작이 많지 않다는 것이다. 자바스크립트 컴파일레이션은 보통 코드가 실행되기 겨우 수백만 분의 일초 전에 수행한다.

#### 1.2 스코프 이해하기

'var a = 2;'라는 구문이 주어지면, 컴파일러는 가장 먼저 토크나이징을 통해 구문을 토큰으로 쪼갠다. 그리고 파싱해 트리 구조로 만든다.
그리고 코드 생성 과정에 들어가면, 컴파일러는 다음 일을 진행한다.

1. 'var a'를 만나면, 스코프에 변수 a가 특정 스코프 내에 있는지 묻는다. 있다면 이 선언을 무시하고 지나간다. 없다면 새로운 변수 a를 스코프 내에 선언하라고 요청한다.
2. 컴파일러는 'a = 2' 대입문을 처리하기 위해, 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 코드를 실행하면, 코드는 먼저 a라는 변수에 현재 스코프 내에서 접근할 수 있는지 확인한다. 가능하다면 확인된 변수 a를 사용하고, 아니라면 다른 중첩 스코프를 살핀다. 엔진이 변수를 마침내 찾으면 변수에 값 2를 넣고, 못 찾으면 에러가 발생했다고 소리칠 것이다.

#### 1.3 중첩 스코프

스코프는 확인자 이름으로 변수를 찾기 위한 규칙의 집합이다. 하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로, 스코프도 다른 스코프 안에 중첩될 수 있다. 중첩 스코프를 확인할 때 사용하는 규칙은 간단하다.

1. 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾기 못하면 한 단계씩 올라간다.
2. 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

#### 1.4 오류

대입할 대상을 검색할 때는 LHS 검색, 대입한 값을 검색할 때는 RHS 검색을 한다. 예를 들어, 어떤 대입 연산문이 있을 때, LHS 검색은 대입 연산자의 왼쪽에 있을 때 수행하고, RHS 검색은 변수가 대입 연산자의 오른쪽에 있을 때 수행한다. 이 두 검색 방식은, 변수를 스코프에서 검색하는 과정에서 찾지 못 했을 때 서로 다르게 동작한다. RHS 검색이 중첩 스코프 안 어디서도 변수를 찾지 못하면 엔진은 'ReferenceError'를 발생시킨다. 반면 LHS 검색이 변수를 찾지 못해 최상위 층에 도착할 때는, 프로그램이 'Strict Mode'로 동작하고 있는 것이 아니라면, 글로벌 스코프가 엔진이 검색하는 이름의 변수를 새로 생성해서 넘겨준다. 없지만 하나 만들어주는 것이다. RHS 검색 결과 변수를 찾았지만 그 값으로 불가능한 일을 하려고 한다면, 엔진은 TypeError를 발생시킨다.

<br />
