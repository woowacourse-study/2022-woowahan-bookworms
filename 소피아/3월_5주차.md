# 03.29 독서 인증

## You Don't Know JS (p.233~243)

### Part 2. 스코프와 클로저

#### 4장 호이스팅

##### 닭이 먼저냐 달걀이 먼저냐

- 선언되지 않은 변수의 대입문을 작성한 후, var 선언문을 작성하고 그 다음 해당 변수를 console.log로 출력하도록 작성하여 실행시키면 출력 결과는 2다.
- 선언되지 않은 변수를 console.log로 출력하는 문장을 작성하고, 변수를 var 선언하고 대입하는 문장을 작성한다. 이후 실행시키면 출력 결과는 undefined다.

어떻게 처리되는 걸까? 무엇이 먼저일까. 선언문(달걀)일까 아니면 대입문(닭)일까?

##### 컴파일러는 두 번 공격한다.

- 컴파일 과정에서, 모든 선언문을 찾아 적절한 스코프에 연결해주는 과정이 있다. 이 과정은 렉시컬 스코프의 핵심이다.

- 자바스크립트는 "var a = 2;"를 두 개의 구문으로 본다. 
  - `var a;`  => 선언문은 컴파일레이션 단계에서 처리된다.
  - `a = 2;` => 대입문은 실행 단계까지 내버려둔다.
- 따라서 변수와 함수 선언문은 실행 단계 전에 처리되므로, 선언된 위치에서 코드의 꼭대기로 끌어올려진다고 비유할 수 있다. 이렇게 선언문을 끌어올리는 동작을 '호이스팅(Hoisting)'이라고 한다. 호이스팅은 스코프별로 작동한다.

- 함수 선언문을 끌어올려지지만 함수 표현식은 다르다. 변수를 먼저 함수로 호출하고, 변수를 선언하면서 익명함수를 대입한다고 가정하자. 선언이 끌어올려져 둘러싼 스코프에 붙으므로 함수 호출은 실패하지 않는다. ReferenceError도 발생하지 않는다. 다만 변수는 아직 값이 없으므로 ,호출 시 undefined를 함수로 호출하려고 하게 되어 TypeError가 발생한다.

##### 함수가 먼저다

함수와 변수 선언문은 모두 끌어올려지는데, **먼저 함수가 끌어올려지고 다음 변수가 올려진다.** 함수 선언문이 일반 변수 위로 끌어올려진다. 중복 선언을 조심하자. 같은 식별자로 일반 변수 선언과 함수 선언을 섞어 사용하면 위험하다.

#### 5장 스코프 클로저

##### 핵심

클로저는 함수가 속한 렉시컬 스코프를 기억하여, 함수가 렉시컬 스코프 밖에서 실행될 때도 이 스코프에 접근할 수 있도록 하는 기능이다.

```javascript
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz();	// 2
```

일반적으로 foo()가 실행된 후에는 foo()의 내부 스코프가 사라졌다고 생각할 것이다. 더는 foo()의 내용을 사용하지 않는 상황이라면, 가비지 콜렉터가 더는 사용하지 않는 메모리이므로 해제시켰을 것이다.

그러나 사실 foo의 내부 스코프는 bar()가 사용 중이라 해제되지 않는다. bar의 선언된 위치 덕에 bar()는 foo() 스코프에 대한 렉시컬 스코프 클로저를 가지고 있다. 즉, foo()의 스코프는 bar()에 의해 참조될 수 있도록 살아있고, bar()는 그 스코프에 대한 참조를 가지고 있다. 이를 클로저라고 부른다.

<br />