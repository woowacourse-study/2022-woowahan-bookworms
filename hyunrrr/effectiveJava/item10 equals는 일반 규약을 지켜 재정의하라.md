# 이펙티브 자바

아이템 10) equals는 일반 규역을 지켜 재정의하라 (p52-)

### equals는 재정의 안하는게 가장 좋다. 아래와 같으면 재정의하지 말자
- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 '논리적 동치성(logical equality)을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.


### equals를 재정의해야 할 때는?
- 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때
<br>(객체 식별성(object identity): 두 객체가 물리적으로 같은가)
- 주로 값 클래스들이 여기 해당됨

### equals 메서드를 재정의할 때 반드시 일반 규약을 따라야 한다. 다음은 Object 명세에 적힌 규약이다.
**equals 메서드는 동치관계(equivalence relation)를 구현하며, 다음을 만족한다.**
- 반사성(reflexivity): null이 아닌 모든 참조 값 x에 대해 x.equals(x)는 true다.
- 대칭성(symmetry): null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true면 y.equals(x)도 true다.
- 추이성(transitivity): null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true이다.
- 일관성(consistency): null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 상항 true를 반환하거나 항상 false를 반환한다.
- null-아님: null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.

### object 명세에서 말하는 동치관계란?
- 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산, 이 부분집합을 동치류(equivalence class; 동치 클래스)라 함
- equals메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다.


### 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
- 즉 상속하면서 새로운 인스턴스 변수를 추가하면 equals 규약을 만족시킬 수 없다.
- equals에서 instanceof 를 사용해 추가된 상태에 대해 검사를 안한다면, 추이성이 깨질것이다.(코드 10-3 참고)
- getClass()를 이용해 다른 타입이면 false를 반환하게 한다면, 리스코프 치환 원칙을 위배한다.(코드 10-4 참고)
- 상속 대신 컴포지션을 사용하면 equals 규약을 만족시킬 수 있다.(코드 10-5 참고))
<br>(추상클래스의 하위 클래스에서라면 equals 구약을 지키면서 값을 추가할 수 있다. 자세한 내용은 p60-61)

### equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다.
- equals를 판단하는데 신뢰할 수 없는 상태가 영향을 주면 안됨
- 네트워크와 같이 외부에 의해 쉽게 바뀔수 있는 ip를 통해 검사하면 안됨
- equals는 항시 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야 한다.


### equals 메서드 구현 방법을 단계별로 정리해보자
1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인
    - 단순 성능 최적화용
2. instanceof 연산자로 입력이 올바른 타입인지 확인, 다르면 false
3. 입력을 올바른 타입으로 형변환
4. 입력 객체와 자기 자신의 대응되는 "핵심" 필드들이 모두 일치하는지 하나씩 검사
    - float와 double을 제외한 기본 타입 필드는 ==연산자로 비교
    - float와 double은 Float.compare(float, float), Double.compare(double, double)로 비교
    - 참조 타입 필드는 각각의 equals 메서드로 비교
    - 동기화용 lock과 같이 객체의 논리적 상태와 관련 없는 필드는 비교하면 안됨
    - 비교 검사가 싼 필드부터 비교하자(성능 최적화를 위해)


### equals를 다 구현했다면 세 가지만 자문해보자
1. 대칭적인가?
2. 추이성이 있는가?
3. 일관적인가?


### equals의 주의사항
- equals를 재정의할 땐 hashCode도 반드시 재정의하자(아이템 11)
- 너무 복잡하게 해결하려 들지 말자
    - 필드의 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있다.
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자


### 꿀팁
구글이 만든 AutoValue 프레임워크를 사용하면 쉽게 할 수 있음
클래스에 애너테이션 하나만 추가하면 됨
