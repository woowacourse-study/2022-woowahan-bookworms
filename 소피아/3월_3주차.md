# 03.14 독서 인증

## 모던 자바스크립트 Deep Dive (p.422 ~ 450)

### 24장. 클로저

#### 클로저란?

- 함수가 선언된 렉시컬 환경을 통해, 이미 실행이 종료된 함수에서 선언된 변수에도 접근할 수 있는 현상.
- 어떤 함수 내부에 중첩 함수가 정의되었을 때, 중첩 함수는 자신이 포함된 함수의 변수에 접근할 수 있는 현상.
- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 외부 함수의 생존 여부(실행 컨텍스트의 생존 여부)와 상관없이, 상위 스코프를 참조할 수 있고, 상위 스코프의 식별자를 참조하고 그 값을 변경할 수도 있는 현상. (실행 컨텍스트의 소멸과 실행 컨텍스트의 렉시컬 환경이 소멸하는 시점이 다르다는 점에 주의하자.)

- 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고, 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.

  1. 중첩 함수가 외부 함수보다 더 오래 유지되지만, 상위 스코프의 어떤 식별자도 참조하지 않는다면 이는 클로저라고 할 수 없다.
     상위 스코프의 어떤 식별자도 참조하지 않는 경우, 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다.
  2. 중첩 함수가 외부 함수의 식별자를 참조하지만, 외부 함수 밖으로 중첩 함수가 반환되지 않아 중첩 함수의 생명주기가 더 짧다면, 생명 주기가 종료된 외부 함수의 식별자를 참조할 수 있는 현상이 나타나지 않으므로, 클로저라고 할 수 없다.

- 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수(free variable)이라고 부른다. 클로저라는 표현은 자유 변수에 함수가 묶여 있는(closed) 것을 의미한다.

#### 렉시컬 스코프

- 클로저가 나타나는 이유는, 자바스크립트가 함수 호출이 아닌 함수 정의 위치에 따라 상위 스코프를 결정하는 렉시컬 스코프(정적 스코프) 방식을 따르기 때문이다.
  함수가 정의된 위치와 호출되는 위치는 다를 수 있다. 렉시컬 스코프가 가능하려면, 함수는 자신의 정의된 환경인 상위 스코프를 기억해야 한다.
  함수 정의가 평가될때, 함수는 상위 스코프를 [[Environment]] 내부 슬롯에 저장한다. 따라서 함수는 자신이 존재하는 한 상위 스코프를 기억할 수 있게 된다.

- let이나 const 키워드를 사용하는 반복문은, 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여, 반복 당시의 상태를 스냅샷을 찍듯 저장한다. 반복문의 코드 블록 내부에서 함수를 정의하면, 정의된 함수의 상의 스코프는 이 스냅샷처럼 저장된 렉시컬 환경이 된다.

#### 클로저의 활용

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태가 의도치 않게 변경되지 않도록 은닉하고, 특정 함수에게만 상태 변경을 허용한다.

<br />

# 03.15 독서 인증

## You Don't Know JS (p.26 ~ 65)

### 1장. 타입

- 자바스크립트에는 7가지 내장 타입이 있다. 7가지 중 object를 제외한 이들을 원시 타입(primitive)이라고 한다.

  null, undefined, boolean, number, string, object, symbol(ES6 추가)

- 값은 타입을 가진다. 값의 타입은 `typeof` 연산자로 알 수 있다. 

  - 주의할 것은, null에 대한 연산 결과가 'object'라는 점이다. null 값을 정확히 확인하려면 두 가지를 확인해야한다. 1. 타입은 'object'이고 2. falsy한 값인가.

  - 'undefined'는 접근 가능한 스코프에 변수가 선언되었으나 값이 할당되지 않은 상태임을 의미한다. 값만 없다는 뜻이다.

    반면 변수 자체가 선언조차 되지 않은 것은 'undeclared'다. 이 경우 'ReferenceError: ??? is not defined'가 나타난다.

    그런데 undefined 변수든, undeclared 변수든 `typeof` 연산 결과는 모두 'undefined'다. 만약 ReferenceError를 피하고 싶다면, 브라우저가 오류 처리를 하지 않기를 원한다면 `typeof`를 이용하여 안전하게 존재 여부를 확인할 수 있다.

- 변수는 언제라도 어떤 형태의 값을 가질 뿐이다.  값에는 타입이 있고, 값을 가지는 변수에는 타입이 없다. 변수에 `typeof` 연산자를 대어보는 것은 정확히는 '이 변수에 들어있는 값의 타입이 무엇이냐'고 묻는 것이다.

### 2장. 값

- null 타입은 값이 null 하나뿐이고, undefined 타입도 값이 undefined 하나뿐이다. undefined는 할당된 값이 없는 모든 변수, 프로퍼티의 default value다.
- `void` 연산자는 어떤 값이라도 undefined로 만든다. `void`연산은 어떤 식의 결괏값이 없다는 걸 확실히 밝힐 때 요긴하게 쓸 수는 있다. 값이 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에 void를 사용할 수 있다. 다만, return에 필요한 경우에는 return 문을 분리하여 결괏값 없이 return 하는 방식을 선호하는 개발자들이 많다. 
- NaN의 type은 Number다. NaN은 '숫자가 아니다'라기보다 '유효하지 않은 숫자'라고 표현하는 것이 더 정확하다. NaN은 NaN 자기 자신과 직접 비교할 수 없다. NaN !== NaN이다. NaN을 확인하기 위해서는, `Number.isNaN()`을 이용한다. 이 외에도 숫자에는 +Infinity, -Infinity, -0 같은 특수 값이 있다.
- ES6부터는 두 값이 절대적으로 동등한지 확인하는 유틸리티 `Object.is()`를 지원한다.
- 자바스크립트의 레퍼런스는 다른 언어의 레퍼런스, 포인터와는 다른 개념으로, 다른 변수나 레퍼런스가 아닌 '값'을 가리킨다.

<br />

