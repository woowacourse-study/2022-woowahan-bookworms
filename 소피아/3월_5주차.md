# 03.29 독서 인증

## You Don't Know JS (p.233~243)

### Part 2. 스코프와 클로저

#### 4장 호이스팅

##### 닭이 먼저냐 달걀이 먼저냐

- 선언되지 않은 변수의 대입문을 작성한 후, var 선언문을 작성하고 그 다음 해당 변수를 console.log로 출력하도록 작성하여 실행시키면 출력 결과는 2다.
- 선언되지 않은 변수를 console.log로 출력하는 문장을 작성하고, 변수를 var 선언하고 대입하는 문장을 작성한다. 이후 실행시키면 출력 결과는 undefined다.

어떻게 처리되는 걸까? 무엇이 먼저일까. 선언문(달걀)일까 아니면 대입문(닭)일까?

##### 컴파일러는 두 번 공격한다.

- 컴파일 과정에서, 모든 선언문을 찾아 적절한 스코프에 연결해주는 과정이 있다. 이 과정은 렉시컬 스코프의 핵심이다.

- 자바스크립트는 "var a = 2;"를 두 개의 구문으로 본다. 
  - `var a;`  => 선언문은 컴파일레이션 단계에서 처리된다.
  - `a = 2;` => 대입문은 실행 단계까지 내버려둔다.
- 따라서 변수와 함수 선언문은 실행 단계 전에 처리되므로, 선언된 위치에서 코드의 꼭대기로 끌어올려진다고 비유할 수 있다. 이렇게 선언문을 끌어올리는 동작을 '호이스팅(Hoisting)'이라고 한다. 호이스팅은 스코프별로 작동한다.

- 함수 선언문을 끌어올려지지만 함수 표현식은 다르다. 변수를 먼저 함수로 호출하고, 변수를 선언하면서 익명함수를 대입한다고 가정하자. 선언이 끌어올려져 둘러싼 스코프에 붙으므로 함수 호출은 실패하지 않는다. ReferenceError도 발생하지 않는다. 다만 변수는 아직 값이 없으므로 ,호출 시 undefined를 함수로 호출하려고 하게 되어 TypeError가 발생한다.

##### 함수가 먼저다

함수와 변수 선언문은 모두 끌어올려지는데, **먼저 함수가 끌어올려지고 다음 변수가 올려진다.** 함수 선언문이 일반 변수 위로 끌어올려진다. 중복 선언을 조심하자. 같은 식별자로 일반 변수 선언과 함수 선언을 섞어 사용하면 위험하다.

#### 5장 스코프 클로저

##### 핵심

클로저는 함수가 속한 렉시컬 스코프를 기억하여, 함수가 렉시컬 스코프 밖에서 실행될 때도 이 스코프에 접근할 수 있도록 하는 기능이다.

```javascript
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz();	// 2
```

일반적으로 foo()가 실행된 후에는 foo()의 내부 스코프가 사라졌다고 생각할 것이다. 더는 foo()의 내용을 사용하지 않는 상황이라면, 가비지 콜렉터가 더는 사용하지 않는 메모리이므로 해제시켰을 것이다.

그러나 사실 foo의 내부 스코프는 bar()가 사용 중이라 해제되지 않는다. bar의 선언된 위치 덕에 bar()는 foo() 스코프에 대한 렉시컬 스코프 클로저를 가지고 있다. 즉, foo()의 스코프는 bar()에 의해 참조될 수 있도록 살아있고, bar()는 그 스코프에 대한 참조를 가지고 있다. 이를 클로저라고 부른다.

<br />

# 03.30 독서 인증

## You Don't Know JS (p.177~189)

### Part 2. 비동기와 성능

#### 1장 비동기성: 지금과 나중

비동기는 프로그램의 어느 부분은 '지금' 실행되고, 다른 부분은 '나중에' 실행되면서 발생하는, 프로그램이 실제로 작동하지 않는 '지금(Now)'과 '나중(Later)' 사이의 간극에 관한 문제다. **프로그램에서 '지금'에 해당하는 부분 그리고 '나중'에 해당하는 부분 사이의 관계가 바로 비동기 프로그램의 핵심이다.**

이런 간극의 유형은, 사용자 입력 대기, 데이터베이스/파일 시스템의 정보 조회, 네트워크를 경유한 데이터 송신 후 응답 대기, 일정한 시간 동안 반복적인 작업 수행(ex. 애니메이션) 등 아주 다양하다. **어떤 방법을 동원하든 우리가 작성한 프로그램은 이 시간 간극에 의한 상태 변화를 올바르게 다룰 수 있어야 한다.**

##### 1.1 프로그램 덩이

자바스크립트 프로그램은 보통 여러 개의 덩이, '지금' 실행 중인 프로그램 덩이와 '나중'에 실행할 프로그램 덩이들로 구성된다. 일반적으로 그 단위는 함수 Function이다.

'나중'은 '지금'의 직후가 아니다. '지금' 당장 끝낼 수 없는 작업은 비동기적으로 처리되므로, 프로그램을 중단(Blocking)하지 않는다.

AJAX 요청을 예로 보자. AJAX 요청은 동기적으로 작동하지 않아 ajax() 결과 값을 변수에 바로 할당할 수 없다. 함수가 응답을 받을 수 있을 때까지 흐름을 중단할 수 있다면, 어떤 변수에 ajax()의 반환값을 할당하는 문장은 문제없이 실행될 것이다. 하지만 AJAX는 그렇게 작동하지 않는다. AJAX는 비동기적으로 '지금' 요청하고 '나중'에 결과를 받는다. 따라서 '지금'부터 '나중'까지 '기다리는' 가장 간단하고도 최적의 방법인 '콜백 함수'를 이용하는 것이다.

- 동기적으로 AJAX 요청을 한다면? 기술적으로는 가능하지만, 브라우저 UI가 얼어붙을 뿐만 아니라 사용자와의 상호 작용도 완전히 마비될 수 있다. 끔찍한 일이다.

- console.log() 메서드는 브라우저 유형과 상황에 따라 출력 데이터가 마련된 직후에 콘솔창에 바로 표시되지 않을 수 있다. 많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문에, 브라우저가 콘솔 I/O를 백그라운드에서 비동기적으로 처리해야 성능상 유리하다. 간혹 **브라우저가 콘솔 I/O를 백그라운드로 전환하는 것이 좋겠다고 결정하면 출력이 지연되어 console.log() 이후 문장이 먼저 실행된 후 출력될 때가 있다. console.log() 이후 변경된 값이 표시되는 문제로 디버깅할 땐, 이런 I/O의 비동기성이 원인일 수 있다.** -> 무조건 콘솔창 결과에 의존하지 말고 JS 디버거의 중단점을 잘 활용하는게 최선이다.

##### 1.2 이벤트 루프

실제로 비동기라는 개념은 없다고도 할 수 있다. 자바스크립트 엔진에 시간이란 개념은 없고, 임의의 자바스크립트 코드 조걱을 주는 대로 받아 처리하는 실행기일 뿐이다. 자바스크립트 코드가 실행되는 '이벤트'를 스케줄링하는 일은 엔진 주위 환경의 몫이다. 

자바스크립트 엔진이 AJAX 요청을 실행한다면, 호스팅 환경에 콜백 함수를 넘겨주면서, 네트워크 요청이 다 끝나서 결과 데이터가 만들어졌을 때 이 함수를 돌려주기를 요청한다. 브라우저는 열심히 응답을 리스닝하다가, 데이터가 도착하면 콜백 함수를 이벤트 루프에 삽입하여 실행 스케줄링한다. setTimeout()은 타이머를 설정하는 함수가, 타이머가 끝나면 환경이 콜백 함수를 이벤트 루프에 삽입한 후, 꺼내어 실행한다. 만약 이벤트 루프가 가득 차있다면, 콜백은 얌전히 줄의 맨 끝에서 대기해야 한다. 때문에 setTimeout은 정확한 타이밍으로 작동하지 않는다. 언제 실행될지는 이벤트 루프 큐의 상황에 따라 달라진다.

- 이벤트 루프 큐는 ES6부터 관리 방식이 완전히 바뀌었다. ES6에 이르러서야 작동 방식이 정확히 규정되어 호스팅 환경이 아닌 자바스크립트 엔진의 관할이 되었다. 이는 프로미스 도입을 계기로 일어난 변화다.

##### 1.3 병렬 스레딩

**비동기는 '지금'과 '나중' 사이의 간극에 관한 용어고, 병렬은 동시에 일어나는 일들과 연관된다.** 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할 수는 없다. 단일 스레드 환경에서는 스레드 간섭이 일어나지 않으므로 스레드 큐에 작업이 쌓여있어도 별 문제가 없다. 하지만 하나의 프로그램에서 여러 스레드를 처리하는 병렬 시스템에서는 예상치 못한 일들이 일어날 수 있다. 동시에 메모리 공간을 공유하면서 문제가 발생할 수 있다. 자바스크립트 프로그램 또한 항상 결정적인 것은 아니다. 콜백 함수의 실행 순서가 상황에 따라 달라진다면, 결괏값이 바뀌는 상황이 생긴다.

자바스크립트는 단일 스레드로, 내부의 코드는 원자적(atomic)이다. 일단 하나의 함수가 실행되면, 그 함수 전체가 실행되고서야 다음 함수가 실행된다는 뜻이다. 이를 완전 실행(Run to Completion)이라 한다. 앞서 말한 것처럼 자바스크립트 또한 똑같은 코드로 다른 결괏값을 가지는 상황이 생길 수 있다. 그런 프로그램은 비결정적이라고 한다. 그러나 이 비결정성은 함수의 순서에 따른 것이고, 스레드처럼 표현식의 처리 순서 수준까지는 아니다. 즉, 스레드보다는 결정적이라고 할 수 있다.