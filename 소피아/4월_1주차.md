# 04.01 독서 인증

## You Don't Know JS (p.205~220)

### Part 2. 비동기와 성능

#### 2장 콜백

##### 2.2 두뇌는 순차적이다.

**실행과 계획 :: 순차적인 두뇌의 계획과 콜백식 비동기 자바스크립트 코드 간의 부조화** 

- 두뇌는 순차적이다. 사림이 정말 멀티태스커일 수 있을까? 인간이 정말 정확히 같은 순간에 두 가지 일을 한꺼번에 생각/추론할 수 있을까? 두뇌의 병렬 멀티 스레딩이 가능할까? 아니다. 사람은 싱글 태스커에 더 가깝다. 주어진 순간에 하나의 생각만 할 수 있다. 우리가 멀티태스킹을 하는 것처럼 보이는 상황도, 실은 우리가 아주 재빠른 컨텍스트 스위치(Context Switch)처럼 행동하고 있는 것 뿐이다. 인간의 두뇌가 이벤트 루프 큐처럼 작동한다. 여러 작업 사이를 재빨리 왔다 갔다 하면서 각 작업을 작고 짧은 덩어리로 쪼개어 동시에 처리하는 것이다. 이를 빨리하면 외부에서는 여러 작업이 병렬로 실행되고 있는 것처럼 보인다.

- 위에서 언급했듯, 실행 단계의 우리의 두뇌에서는 비동기 이벤트가 일어나고 있다. 그러나 우리가 계획을 할 때는 순차적, 동기적인 방향으로 계획하는 것처럼 보인다. 계획의 형태는 비동기 이벤트처럼 보이지 않는다.  동기 코드는 동기적인 두뇌의 사고 흐름과 잘 맞지만, 비동기 코드를 표현하는 방식은 잘 맞을 리 없다. (예를 들어, 사람이 언제 무슨 말을 할지까지 오늘 할 일 목록에 적어두지는 않는다. 단지 목록에 계획된 작업들을 하다가, 말을 해야하는 상황이 생기면 처리(실행)할 뿐이다. 이는 재빠른 콘텍스트 교환을 통해 가능한 일이다. 동기적으로 생각하고 계획하되, 비동기적으로 행동(실행)할 수 밖에 없다.) 그러니 인간이 비동기 흐름을 생각하고 떠올리는 일은 부자연스럽다.  인간은 단계별로 끊어 생각하는 경향이 있고, 콜백은 동기에서 비동기로 전환된 이후론 단계별로 나타내기가 어렵다. 그래서 콜백으로 비동기 자바스크립트를 정확하게 작성하고 추론하여 사용하기란 상당히 어렵다.

```javascript
A( function() {
	B();
	C( function() {
		D();
	})
	E();
})
F();
```

위 코드의 실행 순서는 어떻게 될까? A, D가 비동기 코드라면 `A → F → B → C → E → D`, A, D가 동기 코드가 라면? `A → B → C → D → E → F` 순으로 실행된다. 벌써 이해하기 피곤하다. 중첩을 없애면 더 이해하기가 쉬워질까?

```javascript
listen("click", handler);

function handler() {
    setTimeout(request, 500);
}
function request() {
    ajax("http://some.url.1", response);
}
function response(text) {
    if (text == 'hello') {
        handler();
    }
}
```

이전보다는 알아보기 편하지만, 어쨌거나 콜백 지옥에 취약하다. 이 코드를 추론하자면 한 함수에서 다른 함수로, 그다음 함수로, 흐름을 따라가기 위해 계속 코드를 널뛰기 해야한다. 그나마 이는 단순한 경우지만 실무라면 콜백 함수들이 뒤죽박죽 뒤섞여 추론의 어려움은 그 차원이 달라진다. 

중첩/들여쓰기는 주의를 분산시키는 부수적인 요소다. 위의 예제에서 끝나지 않고 더 복잡한 상황들이 생긴다. 어쨌던 사람의 두뇌가 계획하는 방식이 콜백 지향의 비동기 코드와 잘 맞지 않는다. 

##### 2.3 믿음성 문제

서드 파티가 제공한 유틸리티로 콜백을 넘겨준다면? 제어권을 주고받는 행위 때문에 프로그램에 탈이 날 수 있다. 내가 작성하는 프로그램인데도 실행 흐름은 서드 파티에 의존해야 하는 상황을 제어의 역전(Inversion of Control)이라 한다. 서드 파티에서 콜백을 제대로 처리하지 않는 모든 경우를 열거해보면, 모든 경우의 보완 로직을 구현해 넣는다는 게 얼마나 끔찍한 일인지 실감난다. (콜백을 너무 일찍, 혹은 너무 늦게, 혹은 너무 적게, 너무 많이 부른다, 에러나 예외를 무시한다, 필요한 인자나 환경이 콜백에 정상적으로 전달되지 못한다...) 거기다 우리가 넘겨주는 콜백 자체도 전적으로 믿을만한지 의문이다.

우리가 제어하는 코드에서는, 예기치 못한 상황을 줄이고나 나름의 방어 로직을 짜 넣는다. 개발자 본인이 좌지우지할 수 있는 코드에 포함된 비동기 함수 호출에 대해서도 물론 그렇다. 그렇다면 콜백 자체는 결국 별로 도움이 안 된다. 매번 콜백 함수에서 반복적으로 손수 필요한 장치(관용 코드 Boilerplate, 오버헤드 Overhead)를 만들어야 한다. 거기다 제어의 역전 문제 때문에, 콜백에 예쁜 코드를 삽입해두어도 완전히 잘못 틀어질 수 있다. 꼭 서드 파티 유틸리티를 쓰지 않아도, 제어의 역전으로 믿지 못할 코드를 완화할 장치가 없는 상황에서 콜백을 코딩하는 것은, 잠재적인 버그를 심어놓는 것과 다를 바 없다. 그야말로 지옥이다.

<br />

